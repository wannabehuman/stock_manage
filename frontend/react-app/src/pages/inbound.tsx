import React, { useRef, useState, useEffect } from 'react';
import { ReactTabulator } from "react-tabulator";
import "react-tabulator/lib/styles.css";
import "tabulator-tables/dist/css/tabulator.min.css";
import { DefaultButton } from '../components/button/defaultButton';
import { StockSearch } from '../components/StockSearch';
import './RecentStock.css';
import { inboundService } from '../services/inbound.service';

// Material Dashboard 2 React components
import MDBox from '../md-components/MDBox/index.jsx';
import MDButton from '../md-components/MDButton/index.jsx';
import MDTypography from '../md-components/MDTypography/index.jsx';
import { Card } from '@mui/material';
import BaseCodeSelectionModal from '../components/BaseCodeSelectionModal';


interface InboundItem {
  id?: string; // Í≥†Ïú† ID Ï∂îÍ∞Ä
  stock_code: string;
  inbound_date: Date;
  quantity: number;
  unit: string;
  location: string;
  max_use_period: number;
  remark: string;
  lastUpdated: string;
  rowStatus?: string;
  delete?: string;
}

const Inbound: React.FC = () => {
  const tableRef = useRef<any>(null);

  const [tableData, setTableData] = useState<InboundItem[]>([
    {
      id: `row_${Date.now()}_0`, // Í≥†Ïú† ID ÏÉùÏÑ±
      stock_code: "",
      inbound_date: new Date(),
      quantity: 0,
      unit: "",
      location: "",
      max_use_period: 0,
      remark: "",
      lastUpdated: new Date().toISOString(),
      rowStatus: "INSERT"
    }
  ]);

  const [filteredData, setFilteredData] = useState<InboundItem[]>(tableData);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [itemToDelete, setItemToDelete] = useState<InboundItem | null>(null);
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    type: 'success'
  });
  const [baseCodeModalOpen, setBaseCodeModalOpen] = useState(false);
  const [selectedRowId, setSelectedRowId] = useState<string | null>(null);
  const handleDelete = (item: InboundItem) => {
    setItemToDelete(item);
    setDeleteDialogOpen(true);
  };

  const confirmDelete = () => {
    if (itemToDelete) {
      const updatedData = tableData.filter((item) => item.stock_code !== itemToDelete.stock_code);
      setTableData(updatedData);
      setFilteredData(updatedData);
      setDeleteDialogOpen(false);
      setItemToDelete(null);
    }
  };
  // Îç∞Ïù¥ÌÑ∞ Î°úÎî©
  useEffect(() => {
    const loadInbounds = async () => {
      try {
        const data = await inboundService.getAll();
        // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Ïóê IDÍ∞Ä ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
        const dataWithIds = data.map((item: any, index: number) => ({
          ...item,
          id: item.id || `existing_${Date.now()}_${index}`
        }));
        setTableData(dataWithIds);
        setFilteredData(dataWithIds);
      } catch (error) {
        console.error('Error loading inbounds:', error);
        setNotification({
          open: true,
          message: 'ÏûÖÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.',
          type: 'error'
        });
      }
    };

    loadInbounds();
  }, []);
  const handleSearch = (searchText: string, startDate?: string, endDate?: string) => {
    let filtered = [...tableData];
    
    if (searchText) {
      filtered = filtered.filter((item: InboundItem) => 
        item.stock_code.toLowerCase().includes(searchText.toLowerCase())
      );
    }

    if (startDate && endDate) {
      filtered = filtered.filter((item: InboundItem) => {
        const itemDate = new Date(item.lastUpdated);
        const start = new Date(startDate);
        const end = new Date(endDate);
        return itemDate >= start && itemDate <= end;
      });
    }

    setFilteredData(filtered as InboundItem[]);
  };

  // Í∏∞Ï¥àÏ†ïÎ≥¥ ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handleStockCodeClick = (rowId: string) => {
    console.log("rowId", rowId);
    setSelectedRowId(rowId);
    setBaseCodeModalOpen(true);
  };

  // Í∏∞Ï¥àÏ†ïÎ≥¥ ÏÑ†ÌÉù ÏôÑÎ£å Ìï∏Îì§Îü¨
  const handleBaseCodeSelect = (baseCode: any) => {
    console.log("baseCode", baseCode);
    console.log("selectedRowId", selectedRowId);
    
    if (selectedRowId !== null) {
      // ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞Î•º IDÎ°ú Ï∞æÏïÑÏÑú ÏóÖÎç∞Ïù¥Ìä∏
      const updatedTableData = tableData.map(item => 
        item.id === selectedRowId 
          ? {
              ...item,
              stock_code: baseCode.code,
              unit: baseCode.unit,
              max_use_period: baseCode.max_use_period
            }
          : item
      );
      
      const updatedFilteredData = filteredData.map(item => 
        item.id === selectedRowId 
          ? {
              ...item,
              stock_code: baseCode.code,
              unit: baseCode.unit,
              max_use_period: baseCode.max_use_period
            }
          : item
      );
      
      // tabulator APIÎ•º ÏÇ¨Ïö©Ìï¥ÏÑú IDÎ°ú Ï∞æÏïÑÏÑú ÏóÖÎç∞Ïù¥Ìä∏
      if (tableRef.current && tableRef.current.table) {
        try {
          const tabulator = tableRef.current.table;
          const row = tabulator.getRow(selectedRowId);
          if (row) {
            row.update({
              stock_code: baseCode.code,
              unit: baseCode.unit,
              max_use_period: baseCode.max_use_period
            });
            console.log("Tabulator update successful");
          }
        } catch (error) {
          console.log("Tabulator update failed:", error);
        }
      }
      
      // React state ÏóÖÎç∞Ïù¥Ìä∏
      setTableData(updatedTableData);
      setFilteredData(updatedFilteredData);
    }
    
    setBaseCodeModalOpen(false);
    setSelectedRowId(null);
  };

  const columns: any = [
    {
      title: "Ïû¨Í≥†ÏΩîÎìú",
      field: "stock_code",
      width: 150,
      editor: "input",
      cellClick: (e: any, cell: any) => {
        const row = cell.getRow();
        const rowData = row.getData();
        console.log("Clicked row data:", rowData);
        handleStockCodeClick(rowData.id);
      },
      cellEdited: (cell: any) => {
        const row = cell.getRow();
        const data = row.getData();
        // INSERT ÏÉÅÌÉúÏóêÏÑúÎäî rowStatusÎ•º Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        if (data.rowStatus === "INSERT") {
          console.log("INSERT ÏÉÅÌÉúÏóêÏÑúÎäî ÏÉÅÌÉú Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå");
          return;
        }
        row.update({ rowStatus: "UPDATE" });
        console.log("‚úÖ Ìé∏ÏßëÎê®:", cell.getField(), "‚Üí", cell.getValue());
      }
    },

    {
      title: "ÏûÖÍ≥†ÎÇ†Ïßú",
      field: "inbound_date",
      width: 150,
      editor: "date",
      formatter: (cell: any) => {
        // Date Í∞ùÏ≤¥ ‚Üí yyyy-MM-dd ÌòïÏãùÏúºÎ°ú ÌëúÏãú
        const value = cell.getValue();
        if (!(value instanceof Date)) return value;
        return value.toISOString().slice(0, 10); // yyyy-MM-dd
      },
      mutator: (value: any) => {
        // Î¨∏ÏûêÏó¥Î°ú Îì§Ïñ¥Ïò® Í≤ΩÏö∞ Date Í∞ùÏ≤¥Î°ú Î≥ÄÌôò
        if (typeof value === "string") {
          return new Date(value);
        }
        return value;
      },
      // formatter: "date",
      // formatterParams: {
      //   inputFormat: "YYYY-MM-DD",
      //   outputFormat: "yyyy-MM-dd",
      //   invalidPlaceholder: "(Invalid Date)",
      //   locale: "ko"
      // },
      cellEdited: (cell: any) => {
        const row = cell.getRow();
        const data = row.getData();
        // INSERT ÏÉÅÌÉúÏóêÏÑúÎäî rowStatusÎ•º Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        if (data.rowStatus === "INSERT") {
          console.log("INSERT ÏÉÅÌÉúÏóêÏÑúÎäî ÏÉÅÌÉú Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå");
          return;
        }
        row.update({ rowStatus: "UPDATE" });
        console.log("‚úÖ Ìé∏ÏßëÎê®:", cell.getField(), "‚Üí", cell.getValue());
      }
    },
    {
      title: "ÏûÖÍ≥†ÏàòÎüâ",
      field: "quantity",
      width: 150,
      editor: "number",
      cellEdited: (cell: any) => {
        const row = cell.getRow();
        const data = row.getData();
        // INSERT ÏÉÅÌÉúÏóêÏÑúÎäî rowStatusÎ•º Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        if (data.rowStatus === "INSERT") {
          console.log("INSERT ÏÉÅÌÉúÏóêÏÑúÎäî ÏÉÅÌÉú Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå");
          return;
        }
        row.update({ rowStatus: "UPDATE" });
        console.log("‚úÖ Ìé∏ÏßëÎê®:", cell.getField(), "‚Üí", cell.getValue());
      }
    },
    {
      title: "Îã®ÏúÑ",
      field: "unit",
      width: 100,
      editor: "input",
      cellEdited: (cell: any) => {
        const row = cell.getRow();
        const data = row.getData();
        // INSERT ÏÉÅÌÉúÏóêÏÑúÎäî rowStatusÎ•º Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        if (data.rowStatus === "INSERT") {
          console.log("INSERT ÏÉÅÌÉúÏóêÏÑúÎäî ÏÉÅÌÉú Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå");
          return;
        }
        row.update({ rowStatus: "UPDATE" });
        console.log("‚úÖ Ìé∏ÏßëÎê®:", cell.getField(), "‚Üí", cell.getValue());
      }
    },
    {
      title: "ÏµúÏ¥àÏûÖÍ≥†ÏàòÎüâ",
      field: "initialQuantity",
      width: 130,
      editor: "number",
      cellEdited: (cell: any) => {
      } },
    { title: "ÎπÑÍ≥†", field: "remark", width: 200, editor: "input",      cellEdited: (cell: any) => {
        const row = cell.getRow();
        const data = row.getData();
        // INSERT ÏÉÅÌÉúÏóêÏÑúÎäî rowStatusÎ•º Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        if (data.rowStatus === "INSERT") {
          console.log("INSERT ÏÉÅÌÉúÏóêÏÑúÎäî ÏÉÅÌÉú Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå");
          return;
        }
        row.update({ rowStatus: "UPDATE" });
        console.log("‚úÖ Ìé∏ÏßëÎê®:", cell.getField(), "‚Üí", cell.getValue());
      } },
    { title: "ÏµúÏ¢ÖÏàòÏ†ïÏùº", field: "lastUpdated", width: 150 },
    { title: "ÏÉÅÌÉú", field: "rowStatus", width: 100 },
    {
      title: "ÏÇ≠Ï†ú",
      field: "delete",
      hozAlign: "center",
      width: 60,
      formatter: () => "üóë",
      cellClick: (e: any, cell: any) => {
        const row = cell.getRow();
        if(row.getData().rowStatus === "INSERT") {
          row.delete();
          // setTableData((prev) => prev.filter((item) => item.id !== row.id));
        } else if(row.getData().rowStatus === "DELETE") {
          row.update({ rowStatus: "" });
          row.getElement().classList.remove("deleted-row");
          // setTableData((prev) => prev.filter((item) => item.id !== row.id));
        } else {
          row.update({ rowStatus: "DELETE" });
          row.getElement().classList.add("deleted-row");
          // setTableData((prev) => prev.map((item) => item.id === row.id ? { ...item, rowStatus: "DELETE" } : item));
        }
      }
    },
  ];

  const handleAddRow = () => {
    const newRow: InboundItem = {
      id: `row_${Date.now()}_${tableData.length}`, // Í≥†Ïú† ID ÏÉùÏÑ±
      stock_code: "",
      inbound_date: new Date(),
      quantity: 0,
      unit: "",
      location: "",
      max_use_period: 0,
      remark: "",
      lastUpdated: new Date().toISOString(),
      rowStatus: "INSERT"
    };
    setTableData([...tableData, newRow]);
    setFilteredData([...filteredData, newRow]);
  };
  const handleInboundUpdate = async () => {
    try {
      const updatedData = tableData.filter(item => item.rowStatus !== "" && item.rowStatus !== undefined);
      
      // Ïó¨Îü¨ Ìï≠Î™©ÏùÑ Ìïú Î≤àÏóê Ï†ÄÏû•
      await inboundService.saveStock(updatedData);
      
      // ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•Îêú ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setTableData(updatedData.map(item => ({
        ...item,
        rowStatus: undefined,
        delete: undefined
      })));
      setFilteredData(updatedData.map(item => ({
        ...item,
        rowStatus: undefined,
        delete: undefined
      })));
    } catch (error) {
      console.error('ÏûÖÍ≥† Ï†ÄÏû• Ïã§Ìå®:', error);
      setNotification({
        open: true,
        message: 'ÏûÖÍ≥† Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.',
        type: 'error'
      });
    }
  };


  return (
    <MDBox py={3}>
      
      <Card sx={{ p: 3, mb: 3, backgroundColor: 'white' }}>
        <StockSearch onSearch={handleSearch} />
      </Card>

      <Card sx={{ p: 3, height: '68vh', backgroundColor: 'white' }}>
        <MDBox display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <MDTypography variant="h6" fontWeight="medium">
            Í∏∞Ï¥àÏΩîÎìúÏóê Îì±Î°ùÎêú ÌíàÎ™©ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú ÏûÖÍ≥†ÌíàÏùÑ Îì±Î°ùÌï¥Ï£ºÏÑ∏Ïöî!
          </MDTypography>
          <MDBox display="flex" gap={2}>
            <MDButton variant="outlined" color="info" onClick={handleAddRow} sx={{ fontSize: 14, fontWeight: 600 }}>
              Ìñâ Ï∂îÍ∞Ä
            </MDButton>
            <MDButton 
              variant="gradient" 
              color="success"
              sx={{ fontSize: 14, fontWeight: 600 }}
              onClick={() => {
                const filteredDataToSave = tableData.filter(item => item.rowStatus !== "" && item.rowStatus !== undefined);
                const invalidItems = filteredDataToSave.filter(item => {
                  return !item.stock_code || item.stock_code.trim() === '' ||
                         typeof item.quantity !== 'number' || item.quantity < 0;
                });
                // if (invalidItems.length > 0) {
                //   alert('ÌïÑÏàò ÌïÑÎìúÍ∞Ä ÎàÑÎùΩÎêòÏóàÍ±∞ÎÇò ÏûòÎ™ªÎêú Í∞íÏù¥ ÏûàÏäµÎãàÎã§');
                //   return;
                // }
                inboundService.saveStock(filteredDataToSave);
              }}
            >
              ÏûÖÍ≥† Ï†ÄÏû•
            </MDButton>
          </MDBox>
        </MDBox>

        <MDBox sx={{ 
          flex: 1,
          overflow: 'hidden',
          '& .tabulator': {
            backgroundColor: 'white !important',
            border: '1px solid #eee',
            width: '100% !important',
            height: '100% !important',
            fontSize: { xs: '12px', sm: '13px', md: '14px' },
            overflow: 'auto',
          },
          '& .tabulator-tableholder': {
            overflow: 'auto !important',
            maxHeight: { xs: 'cal√•c(50vh - 120px)', sm: 'calc(55vh - 120px)', md: 'calc(65vh - 120px)' },
          },
          '& .tabulator-header': {
            backgroundColor: 'white !important',
            borderBottom: '1px solid #dee2e6',
          },
          '& .tabulator-col': {
            backgroundColor: 'white !important',
          },
          '& .tabulator-col-content': {
            backgroundColor: 'white !important',
          },
          '& .tabulator-cell': {
            backgroundColor: 'white !important',
            borderRight: '1px solid #dee2e6',
          },
          '& .tabulator-row': {
            backgroundColor: 'white !important',
          },
          '& .tabulator-row:hover': {
            backgroundColor: '#f5f5f5 !important',
          },
          '& .tabulator-row-even': {
            backgroundColor: 'white !important',
          },
          '& .tabulator-row-odd': {
            backgroundColor: 'white !important',
          },
          '& .deleted-row': {
            backgroundColor: '#ffebee !important',
            textDecoration: 'line-through',
            opacity: 0.6,
          }
        }}>
          <ReactTabulator
            ref={tableRef}
            data={filteredData}
            columns={columns}
            layout="fitDataStretch"
            options={{ 
              movableRows: true, 
              movableColumns: true,
              index: "id",
              height: "100%",
              layoutColumnsOnNewData: true,
              maxHeight: "100%",
              pagination: false,
              virtualDom: true,
              virtualDomBuffer: 50,
            }}
          />
        </MDBox>
      </Card>

      {/* Í∏∞Ï¥àÏ†ïÎ≥¥ ÏÑ†ÌÉù Î™®Îã¨ */}
      <BaseCodeSelectionModal
        open={baseCodeModalOpen}
        onClose={() => setBaseCodeModalOpen(false)}
        onSelect={handleBaseCodeSelect}
      />
    </MDBox>
  );
};

export default Inbound;
